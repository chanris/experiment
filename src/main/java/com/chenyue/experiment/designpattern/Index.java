package com.chenyue.experiment.designpattern;

/**
 * @author chenyue7@foxmail.com
 *
 * 设计模式 https://refactoringguru.cn/design-patterns/creational-patterns
 *
 * 开闭原则:对修改关闭,对扩展开放
 * 里氏替换原则:子类继承父类,除了添加新的方法完成新增功能,尽量不要重写父类的方法
 * 依赖倒置原则:高层模块不应该依赖低级模块,两者都应该依赖其抽象;抽象不应该依赖细节,
 * 细节依赖抽象,也就是说面向接口编程
 * 单一职责原则:简单来说,一个类一个接口只需承担自己应该做的功能,其他的功能应该剥离出去
 * 接口隔离原则:将庞大的接口功能,分割成更小的接口
 * 迪米特法则:最小知识原则,目的为了降低模块之间的耦合
 * 合成复用原则:要求在软件复用时,要尽量先进行组合或者聚合等关联关系来实现,其次在考虑使用继承关系来实现
 *
 * 创建型模式:将对象的创建与使用分离,降低系统的耦合度
 * 单例(Singleton):
 *   单例的优点:保证了内存中只有一个实例,减少了内存的开销
 *             避免了对资源的多重占用,
 *             单例设置了全局访问点,优化和共享资源的访问
 *         缺点:违反了开闭原则,如果要扩展必须修改原来的代码
 *              在并发测试中,单例模式不利于代码调试,在调试过程中,
 *              单例中的代码没有执行完,也不能模式生成一个新的对象
 *              单例的功能代码通常写在一个类中,如果功能设计不合理,容易违法单一职责原则
 *
 * 原型(Prototype):
 * 工厂方法(Factory Method):
 * 抽象工厂(Abstract Factory):
 * 建造者(Builder):
 *
 * 结构型模式:
 * +代理模式:
 *      代理定义由于某些原因需要给某对象提供一个代理控制以控制对该对象的访问
 *      代理模式优点:
 *          代理模式在客户端与目标对象之间起到一个中介作用和保护对象作用
 *          代理模式可以扩展目标对象的功能呢
 *          降低耦合,增加系统的可扩展性
 *      缺点:
 *          在系统设计在类的数量增加
 *          会造成请求处理的速度降低
 *          增加系统的复杂度
 * *适配器模式:
 * 桥接模式:
 * +装饰(Decorator)模式:
 *      在不改变现有对象结构的情况下,动态地给该对对象增加一些职能
 *      模式的结构:
 *      1.抽象构件
 *      2.具体构件
 *      3.抽象装饰
 *      4.具体装饰
 *
 *
 * 外观模式:
 * 享元模式:
 * 组合模式:
 *
 *
 * 行为模式
 * +模板方法:
 * +策略模式:
 * 命令模式:
 * 责任模式:
 * 状态模式:
 * 观察者模式:
 * 中介者模式:
 * +迭代器模式:
 * 访问者模式:
 * 备忘录模式:
 * 解释器模式:
 *
 */
public final class Index {
}
