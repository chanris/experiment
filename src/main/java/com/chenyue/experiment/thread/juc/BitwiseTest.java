package com.chenyue.experiment.thread.juc;

/**
 * @author chenyue7@foxmail.com
 * @date 2024/7/13
 * @description 测试位运算，
 */
@SuppressWarnings("all")
public class BitwiseTest {
    public static void main(String[] args) {

        /**
         * 为什么1 按位取反是-2
         *
         * 1的补码为 0000 0000 0000 0000 0000 0000 0000 0001
         * 按位取反：1111 1111 1111 1111 1111 1111 1111 1110（补码）
         * 反码：1111 1111 1111 1111 1111 1111 1111 1101
         * 原码：1000 0000 0000 0000 0000 0000 0000 0010 （-2）
         */
        int a = 1;
        System.out.println(~a); // -2

        int MIN_VALUE = 0x80000000; // -0/-2147483648
        /**
         * 为什么-0 表示-2147483648? http://47.109.110.189/article/detail/59
         *
         * 原码 1000 0000 0000 0000 0000 0000 0000 0000
         * 反码 1111 1111 1111 1111 1111 1111 1111 1111
         * 补码 1000 0000 0000 0000 0000 0000 0000 0000
         */
        int x = 0xffffffff; // -2147483648
        System.out.println(MIN_VALUE + 1);

        /**
         * 0xfffffff为什么是-1?
         * 原码 1000 0000 0000 0000 0000 0000 0000 0001
         * 反码 1111 1111 1111 1111 1111 1111 1111 1110
         * 补码 1111 1111 1111 1111 1111 1111 1111 1111 (0xffffffff)
         */
        System.out.println(0xffffffff);

        /**
         *  那么-2147483647十六进制补码是多少?
         *
         *  原码 1111 1111 1111 1111  1111 1111 1111 1111
         *  反码 1000 0000 0000 0000 0000 0000 0000 0000
         *  补码 1000 0000 0000 0000 0000 0000 0000 0001
         */
        int y = 0x80000001;
        System.out.println(y == MIN_VALUE + 1);

        /**
         * 为什么 Integer.MIN_VALUE - 1 = Integer.MAX_VALUE
         * -2147483648
         * 原码：（-0） 1000 0000 0000 0000 0000 0000 0000 0000
         * 反码：1111 1111 1111 1111  1111 1111 1111 1111
         * 补码：1000 0000 0000 0000 0000 0000 0000 0000
         *
         * -1
         * 原码：1000 0000 0000 0000 0000 0000 0000 0001
         * 反码：1111 1111 1111 1111  1111 1111 1111 1110
         * 补码: 1111 1111 1111 1111  1111 1111 1111 1111
         *
         * (-2147483648 ) + (-1) 计算机底层是 补码相加
         * (1000 0000 0000 0000 0000 0000 0000 0000) + (1111 1111 1111 1111  1111 1111 1111 1111)
         * = (0111 1111 1111 1111  1111 1111 1111 1111) 得到的是补码
         * 补码 0111 1111 1111 1111  1111 1111 1111 1111 的原码是什么？因为符号位是0，则是正数， 正数的补码、反码、原码都一样。
         * 故，（0111 1111 1111 1111  1111 1111 1111 1111）= 2147483647
         *
         * 负数的原码、反码、补码转换不会影响符号位。
         */
        System.out.println(Integer.MIN_VALUE - 1 == Integer.MAX_VALUE);
    }
}
